"""
callables_genes_degeneracy.py - get number of syn and nonsyn
callable sites for each provided gene
"""

import csv
import pysam
import argparse
from tqdm import tqdm
from callable_sites_degeneracy import create_degen_lookup

def args():
    parser = argparse.ArgumentParser(
        description='count S and NS callables in genes', 
        usage='python callable_genes_degeneracy.py [options]')

    parser.add_argument('-c', '--callables_table', required=True,
        type=str, help='Path to callables table')
    parser.add_argument('-g', '--gff', required=True,
        type=str, help='GFF containing genes of interest')
    parser.add_argument('-t', '--annotation_table', required=True,
        type=str, help='Path to annotation table (.txt.gz)')
    parser.add_argument('-o', '--outname', required=True,
        type=str, help='File to write to')

    args = parser.parse_args()

    return args.callables_table, args.gff, args.annotation_table, args.outname

def count_gene_sites(callables_table, gff, annotation_table, outname):
    """main function to count callable sites in provided gene list by degeneracy

    does one gene at a time - assumes GFF is sorted by chrom

    generates lookup for single chrom (via create_degen_lookup from
    callable_sites_degeneracy.py) and refers to that across gene coords
    to get per-gene callable counts

    will write entire attribute column (so that multiple gene names can
    be referenced if needed)

    both callables table and ant file must be tabixed

    modified from callable_sites_degeneracy.count_sites()

    Parameters
    ----------
    callables_table : str
        path to callables table generated by callable_sites.py
    gff : str
        path to GFF containing genes of interest
    annotation_table : str
        path to annotation table
    outname : str
        file to write to


    Returns
    -------
    None
    """

    callables_reader = pysam.TabixFile(callables_table)
    header = callables_reader.header[0].split('\t')
    samples = [colname for colname in header
               if colname.endswith('0') or colname.endswith('5')]

    with open(outname, 'w') as f_out:
        fieldnames = ['sample', 'gene_name', 'chrom', 'start', 'end', 
            'fold0', 'fold2', 'fold3', 'fold4', 'nonsyn', 'syn']
        writer = csv.DictWriter(f_out, fieldnames=fieldnames, delimiter='\t')
        writer.writeheader()

        with open(gff, 'r') as f_in:
            gff_fieldnames = ['chrom', 'source', 'feature', 'start', 'end',
                'score', 'strand', 'frame', 'attribute']
            reader = csv.DictReader(f_in, delimiter='\t', fieldnames=gff_fieldnames)
            current_chrom = None

            for gene in tqdm(reader):
                chrom, start, end = gene['chrom'], int(gene['start']), int(gene['end'])

                d = {}
                for sample in samples:
                    d[sample] = {'0': 0, '2': 0, '3': 0, '4': 0}

                if current_chrom != chrom:
                    current_chrom = chrom
                    tqdm.write(f"[saltMA] creating lookup for {gene['chrom']}")
                    current_lookup = create_degen_lookup(annotation_table, gene['chrom'])

                # iterate through sites of gene and count callable sites per sample
                for record in callables_reader.fetch(chrom, start, end): 
                    record = record.split('\t')
                    degen = current_lookup[int(record[1])-1] 
                    if degen == '.':
                        continue

                    sample_indices = [i for i, value in enumerate(record)
                        if value == '1' and i != 1] # second check prevents pos from being counted
                    for idx in sample_indices:
                        d[header[idx]][degen] += 1

                out_dict = {}
                for sample in samples:
                    out_dict['sample'], out_dict['gene_name'] = sample, gene['attribute']
                    out_dict['chrom'], out_dict['start'], out_dict['end'] = chrom, start, end
                    for degen in ['0', '2', '3', '4']:
                        out_dict[f'fold{degen}'] = d[sample][degen]
                    out_dict['nonsyn'] = d[sample]['0'] + (d[sample]['3'] * 1/3) + (d[sample]['2'] * 2/3)
                    out_dict['syn'] = d[sample]['4'] + (d[sample]['3'] * 2/3) + (d[sample]['2'] * 1/3)
                    writer.writerow(out_dict)

def main():
    count_gene_sites(*args())    

if __name__ == '__main__':
    main()

        

